% Dylan Shadduck
% EEC 289A Spring 2021
% Homework 3

clear
clc

% Same problem as homework 2. We are gambling our money with several
% different policies. The first policy is the greedy policy in which the
% the user will gamble all of their money each time. The second is the
% conservative policy. Here the user always bets only 1 dollar. The last
% policy is the random one. In this policy the user bets a random integer
% amount of money between 1 dollar and the total money the user has in a
% uniform distribution. The reward seen each time the game is played is the
% amount of money earned or lost (positive or negative reward). The game
% ends when the user has no money or has 10 dollars or more. 

%% Policy iteration

% Probability of heads
hp = 0.9;

% There are 11 possible states representing how much money the player has
% at the beginning of their turn
states = linspace(0, 10, 11);
V = zeros(1, 11);

% Initialize a random policy matrix
P = zeros(1,9);
for s=1:9
    P(s) = randi(s);
end

% Define a delta for exiting the while loop for policy eval
delta = 1;

while true
    % This loop should only exit when our policy converges to the optimal
    % policy
    
    while delta > 0.001
        % Policy evaluation
        delta = 0;
        for s=1:9
            v = V(s+1);
            r = P(s);
            if s+r >= 10
                eval = 
            V(s+1) = hp*(r + V(s+1+r)) + (1-hp)*(-r + V(s+1-r));
            delta = max([delta abs(v - V(s+1))]);
        end
    end
    
    % We want to save the current state of our policy
    pi = P;
    
    for s=1:9
        % Check each possible policy and see if it is better than our
        % current policy
        for j=1:s
            % Create a temp array for all possible policy evaluations
            temp = zeros(1, s);
            
            Vj = hp*(j + V(s+1+j)) + (1-hp)*(-j + V(s+1-j));
            temp(j) = Vj;
        end
        % Check if this new policy returns a greater value than
        % previous
        [~, new_p] = max(temp);
        
        % If best policy is different than the current policy, update our
        % policy array
        P(s) = new_p;
    end
    
    % Check if our policy array has changed
    if isequal(pi, P)
        % If our policy has not changed, we have 
        break
    end
end